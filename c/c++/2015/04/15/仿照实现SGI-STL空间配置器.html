
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>仿照实现SGI-STL空间配置器 | WordWorth</title>
    <meta name="description" content="简单的STL Allocator实现">
    <meta name="author" content="sosohu">
    <meta name="keywords" content="STL, Allocator">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="/assets/themes/flying/bootstrap/css/bootstrap.min.css" rel="stylesheet">
    <link href="/assets/themes/flying/css/style.css" rel="stylesheet" type="text/css" media="all">
    <link href="/assets/themes/flying/css/syntax.css" rel="stylesheet" type="text/css" media="all">
    <script type="text/javascript" src="/assets/themes/flying/js/jquery-1.9.1.min.js"></script>
   <!-- Le fav and touch icons -->
  <!-- Update these with your own images
    <link rel="shortcut icon" href="images/favicon.ico">
    <link rel="apple-touch-icon" href="images/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="72x72" href="images/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="114x114" href="images/apple-touch-icon-114x114.png">
  -->
</head>

  <body>

    <div class="navbar">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="/">WordWorth</a>
          <ul class="nav">
		<li><a href="/about.html">About</a></li>
		<li><a href="/archive.html">Archive</a></li>
		<li><a href="/categories.html">Categories</a></li>
<!--		<li><a href="http://wiki.zhouyichu.com">Wiki</a></li>  -->
		<li class="offset3"><a href="/atom.xml">Subscribe</a></li>
		<li><a id="random" href="#">Random</a></li>
          </ul>
        </div>
      </div>
    </div>

    <div class="container">

      <div class="content">
        
<div class="page-header">
  <h1>仿照实现SGI-STL空间配置器 <small class="H1_Date">--15 April 2015</small></h1>
</div>

<div class="row">
  <div class="span8">
    <p>STL里面的Allocator是用来管理空间分配的，这里的空间基本上指的就是内存，管理内存是影响到很多STL的容器性能的主要因素之一，所以对Allocator的了解需要非常深入而不是仅仅知道如何调用．笔者前段时间大致的看了<strong>侯捷</strong>老师的那本<strong>&lt;&lt;STL源码剖析>></strong>，对SGI版本的STL算是有点简略的认识，可是这种走马观花的认识也只能帮助我理解其大致机理，当遇到真正让你实现一个简单的Allocator时候就会显得束手无策，所以有必要通过编码，简单临摹一下SGI的Allocator.</p>

<h2>简单粗暴Naive方式实现Allocator</h2>

<p>我们可以编写一个最简单的符合STL规范的Naive版本的Allocator,它起码需要allocate/deallocate函数用来申请/释放空间，construct/destroy函数用来在内存空间上构造和析构对象, 还有rebind成员模板以及一些类型别名等.</p>

<p>这个Allocator只是简单的申请/释放空间，没有任何特别之处.</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">allocator</span><span class="p">{</span>

<span class="k">public</span><span class="o">:</span>
<span class="c1">//常用类型别名,符合STL规范</span>
    <span class="k">typedef</span> <span class="n">T</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">T</span><span class="o">*</span> <span class="n">pointer</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span> <span class="n">const_pointer</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">const_reference</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">int</span> <span class="n">difference_type</span><span class="p">;</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">rebind</span><span class="p">{</span>
        <span class="k">typedef</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">allocator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">allocator</span><span class="p">(</span><span class="k">const</span> <span class="n">allocator</span> <span class="o">&amp;</span><span class="n">rhs</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">allocator</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="c1">//常用函数, 符合STL规范</span>
    <span class="n">pointer</span> <span class="nf">allocate</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">hint</span><span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="n">pointer</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">);</span>

    <span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">construct</span><span class="p">(</span><span class="n">pointer</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">destroy</span><span class="p">(</span><span class="n">pointer</span> <span class="n">p</span><span class="p">);</span>

    <span class="n">pointer</span> <span class="n">address</span><span class="p">(</span><span class="n">const_reference</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pointer</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">allocate</span><span class="p">(</span><span class="n">size_type</span> <span class="n">n</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span><span class="o">*</span> <span class="n">hint</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">_allocate</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="n">pointer</span><span class="p">)</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">deallocate</span><span class="p">(</span><span class="n">pointer</span> <span class="n">p</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">n</span><span class="p">){</span>
    <span class="n">_deallocate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size_type</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">UINT_MAX</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">construct</span><span class="p">(</span><span class="n">pointer</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">){</span>
    <span class="n">_construct</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">destroy</span><span class="p">(</span><span class="n">pointer</span> <span class="n">ptr</span><span class="p">){</span>
    <span class="n">_destroy</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">pointer</span> <span class="n">allocator</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">address</span><span class="p">(</span><span class="n">const_reference</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">pointer</span><span class="p">)</span><span class="o">&amp;</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>


<p>上面用到的<em>allocate, </em>deallocate, <em>construct和</em>destroy函数定义如下:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="n">T</span><span class="o">*</span> <span class="n">_allocate</span><span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">size</span><span class="p">,</span> <span class="n">T</span><span class="o">*</span><span class="p">){</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span><span class="o">*</span><span class="p">)(</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">size</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">))));</span>
    <span class="c1">// ::operator new 最底层的内存分配，类似malloc</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">qError</span><span class="p">(</span><span class="s">&quot;out of memory, allocate failed.&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">qDebug</span><span class="p">(</span><span class="s">&quot;_allocate&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">_deallocate</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span>
    <span class="o">::</span><span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
    <span class="n">qDebug</span><span class="p">(</span><span class="s">&quot;_deallocate&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">_construct</span><span class="p">(</span><span class="n">T1</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">){</span>
    <span class="k">new</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">T1</span><span class="p">(</span><span class="n">value</span><span class="p">);</span> <span class="c1">//new 指定内存位置的用法</span>
    <span class="n">qDebug</span><span class="p">(</span><span class="s">&quot;_construct&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kr">inline</span> <span class="kt">void</span> <span class="n">_destroy</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">){</span>
    <span class="n">p</span><span class="o">-&gt;~</span><span class="n">T</span><span class="p">();</span>
    <span class="n">qDebug</span><span class="p">(</span><span class="s">&quot;_destroy&quot;</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>


<h2>SGI版本的两级Allocator实现</h2>

<p>SGI的Allocator有两个版本，一个是类似上面提到的Naive版本，它是为了兼容通用的STL标准，但是这个版本SGI从来不用，而是使用两级的Allocator，这个Allocator与STL标准不兼容，只能被SGI-STL的容器使用,这里就简单介绍一下SGI两级Allocator的设计思路.</p>

<p><strong>两级Allocator</strong></p>

<blockquote><p>  SGI的Allocator分为一级和二级Allocator,其中一级Allocator负责管理大于128字节的内存请求，而二级Allocator负责小于等于128字节的内存请求．</p></blockquote>

<h3>一级Allocator</h3>

<p>这里我实现的一级Allocator名字叫做superior_allocator,它的成员函数解释如下:</p>

<ul>
<li>allocate函数负责分配指定大小内存</li>
<li>deallocate函数负责释放指定指针的内存</li>
<li>reallocate函数负责再次申请扩充内存</li>
<li>set_allocate_failed_handler函数用来接受使用者定义的内存不足处理函数，在遇到内存不足时候可以调用此函数期望释放部分内存</li>
<li>oom_allocate函数用来处理allocate函数分配内存时候由于内存不足而失败这种情况</li>
<li>oom_reallocate函数用来处理reallocate函数分配内存时候由于内存不足而失败这种情况</li>
</ul>


<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">superior_allocator</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="c1">//allocate when out of memory</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">oom_allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">oom_reallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">old_sz</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_sz</span><span class="p">);</span>
    <span class="c1">// use defined handler when out of memory</span>
    <span class="k">static</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">allocate_failed_handler</span><span class="p">)();</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">reallocate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">old_sz</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_sz</span><span class="p">);</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="nf">set_allocate_failed_handler</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">)());</span>
<span class="p">};</span></code></pre></div>


<p>其中具体函数实现如下:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="c1">//初始化内存不足处理函数指针</span>
<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="p">(</span><span class="o">*</span> <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">allocate_failed_handler</span><span class="p">)()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">oom_allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">oom_allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">allocate_failed_handler</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">hu</span><span class="o">::</span><span class="n">THROW_BAD_ALLOC</span><span class="p">;</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">//一直在不断的循环尝试</span>
    <span class="k">while</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="c1">//调用处理例程，试图释放一些内存</span>
        <span class="n">allocate_failed_handler</span><span class="p">();</span> 
        <span class="n">result</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">){</span>
    <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">reallocate</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span>
                                <span class="kt">size_t</span> <span class="n">old_sz</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_sz</span><span class="p">){</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_sz</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">oom_reallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">old_sz</span><span class="p">,</span> <span class="n">new_sz</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">oom_reallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span>
                                <span class="kt">size_t</span> <span class="n">old_sz</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_sz</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">allocate_failed_handler</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">throw</span> <span class="n">THROW_BAD_ALLOC</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
        <span class="n">allocate_failed_handler</span><span class="p">();</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_sz</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>


<p>从实现代码可以看出来，一级Allocator其实也很简单，和上面提到的Naive方式几乎差不多，就是malloc/free/realloc, 遇到malloc/realloc失败的话不断的调用用户处理函数以释放部分内存.之所以这么简单，是因为一级Allocator一般只处理较大内存块的分配管理，所以可以不用像二级Allocator那么斤斤计较，管理严密.</p>

<h3>二级Allocator</h3>

<p>这里我编写的二级Allocator名字叫做junior_allocator,它是完全按照SGI的设计思路实现的，负责较小内存块的管理.</p>

<h4>free_list指针数组</h4>

<p>要了解SGI二级Allocator的原理就必须先了解free_list指针数组，free_list指针数组的原型如下:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="n">obj</span><span class="o">*</span> <span class="n">free_list</span><span class="p">[</span><span class="n">FREE_COUNT</span><span class="p">];</span></code></pre></div>


<p>这里势必要介绍一下obj的原型:</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">union</span> <span class="n">obj</span><span class="p">{</span>
    <span class="n">obj</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">data</span><span class="p">[];</span>
<span class="p">};</span></code></pre></div>


<p>这个obj的设计非常巧妙，是一个union,这样设计有以下几点好处:</p>

<ul>
<li>一个obj的地址也就是其data指针值，这样方便通过obj的data值读出其内存地址.

<blockquote><p>  例如, 我们有obj o那么o.data其实就是&amp;o, 也就执行o的具体位置</p></blockquote></li>
<li>一个obj的next字段用来存储指向下个节点的位置,这样能形成类似链表一样的结构.</li>
<li>通过union结合就可以避免单独开辟空间存储指针的空间浪费</li>
</ul>


<p>结合obj的原型我们再来看free_list指针数组，我们这里free_list指针数组的大小FREE_COUNT = 128 / 8 = 16, 于是有16个obj指针，这16个obj指针分别指向第一个空闲的8字节,16字节,...,128字节内存块的位置</p>

<p>我们可以初始化时候为每个free_list[i]申请连续20个相应块空间，作为备用，初始化之后的内存使用情形如下图:</p>

<p><img src="http://sosohu.github.io/assets/image/posts/2015-4-15-Alloc/free_lst.jpg" alt="free_list" /></p>

<p>上图的free_lst指针数组中的指针指向其对应第一个空闲块，然后后续空闲块通过神奇的obj*连接而成，这里就可以体现到obj设计的精妙了，它一点也不浪费空间，而且还是非常精简的.</p>

<p>另外，对于上图需要解释的就是start_free到end_free这块空间就是junior_allocator分配的还未被使用的空闲内存池.</p>

<h4>allocate和deallocate的实现</h4>

<p>reallocate基本上就是调用allocate和deallocate,这里就不作表述.</p>

<h5>allocate过程</h5>

<p>我们试图从junior_allocator申请大小为n字节的内存,如果n > 128，那么交给superior_allocator完成,否则先根据n的大小算出相应内存块大小，比如n = 7那么内存块大小就是8.接着从free_list中找出相应的内存块第一个空闲内存地址free_list[i]，如果此时有空闲块，那么返回此块地址，并且<code>free_list[i] = free_list[i]-&gt;next</code>即指向下一个空闲块;如果不存在空闲块，那么试图从空闲的内存池中申请一块连续的内存，然后切分成free_list[i]对应内存块大小的小块,然后更新free_list[i].</p>

<p>这里我们可以看到，每次某个内存块不够用时候就从内存池取出新的加入，总有内存池用完的时候，当内存池用完了该怎么办呢？这里有两个解决办法:</p>

<ul>
<li>通过malloc再申请一快大内存池</li>
<li>如果系统所有内存都不够了，那只能从其他free_list中扣除一些内存过来了，因为每个free_list[i]都分配了一定数量的内存块，而有些free_list[i]可能用的很少，所以尚存空闲块，那就把它们的抢占过来.</li>
</ul>


<h5>deallocate</h5>

<p>deallocate实现非常简单，如果释放的空间大于128字节，那么就交给一级allocator处理；如果不是,则把内存块加到对应free_list[i]中，通常做法就是直接插入大free_list[i]对应链表的表头.</p>

<h4>代码实现</h4>

<h5>junior_allocator类定义</h5>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">const</span> <span class="kt">size_t</span> <span class="n">LARGE_SIZE</span> <span class="o">=</span> <span class="mi">128</span><span class="p">;</span> <span class="c1">//超过128B就由superior_allocator分配</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">SLICE_SIZE</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">//递增片大小</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">FREE_COUNT</span> <span class="o">=</span> <span class="n">LARGE_SIZE</span><span class="o">/</span><span class="n">SLICE_SIZE</span><span class="p">;</span> <span class="c1">//free list个数，8,16,...128</span>
<span class="k">const</span> <span class="kt">size_t</span> <span class="n">CHUNK_NUM</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">//默认每个尺寸的chunk一次分配的个数</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">junior_allocator</span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
    <span class="k">union</span> <span class="n">obj</span><span class="p">{</span>
        <span class="n">obj</span><span class="o">*</span> <span class="n">next</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">data</span><span class="p">[];</span>
    <span class="p">};</span>
    <span class="c1">//free_list指针数组</span>
    <span class="k">static</span> <span class="n">obj</span><span class="o">*</span> <span class="n">free_list</span><span class="p">[</span><span class="n">FREE_COUNT</span><span class="p">];</span>
    <span class="k">static</span> <span class="kt">char</span><span class="o">*</span> <span class="n">start</span><span class="p">;</span> <span class="c1">//当前可分配内存池的开始位置</span>
    <span class="k">static</span> <span class="kt">char</span><span class="o">*</span> <span class="n">finish</span><span class="p">;</span> <span class="c1">//内存池结束位置</span>
    <span class="k">static</span> <span class="kt">size_t</span> <span class="n">heap_size</span><span class="p">;</span> <span class="c1">//当前堆大小</span>

    <span class="c1">//计算size应该分配的内存块的编号</span>
    <span class="c1">//8字节内存块对应0号,16字节内存块对应1号...</span>
    <span class="k">static</span> <span class="kt">size_t</span> <span class="nf">march_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
    <span class="c1">//计算第node_id号内存块的大小</span>
    <span class="k">static</span> <span class="kt">size_t</span> <span class="nf">node_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">node_id</span><span class="p">);</span>

    <span class="c1">//从内存池申请n个node_id号内存块大小的连续内存</span>
    <span class="k">static</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">chunk_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">node_id</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&amp;</span> <span class="n">n</span><span class="p">);</span>
    <span class="c1">//通过从内存池取新的内存将free_list[node_id]重新填充</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">refill</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">node_id</span><span class="p">);</span>
<span class="k">public</span><span class="o">:</span>

    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">reallocte</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">old_zs</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_sz</span><span class="p">);</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="nf">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>

<span class="p">};</span></code></pre></div>


<h5>superior_allocator成员函数具体实现</h5>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">finish</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">size_t</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">heap_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="k">typename</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">obj</span><span class="o">*</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">free_list</span><span class="p">[</span><span class="n">FREE_COUNT</span><span class="p">]</span>
                    <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">size_t</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">march_node</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">SLICE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">size_t</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">node_size</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">node_id</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">node_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">SLICE_SIZE</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">char</span><span class="o">*</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">chunk_alloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">node_id</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">){</span>
    <span class="kt">size_t</span> <span class="n">requre</span> <span class="o">=</span> <span class="n">n</span><span class="o">*</span><span class="n">node_size</span><span class="p">(</span><span class="n">node_id</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">size_left</span> <span class="o">=</span> <span class="n">finish</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">size_left</span> <span class="o">&lt;</span> <span class="n">requre</span><span class="p">){</span><span class="c1">//剩余空间不够</span>
        <span class="k">if</span><span class="p">(</span><span class="n">node_size</span><span class="p">(</span><span class="n">node_id</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">size_left</span><span class="p">){</span>
            <span class="c1">//还够分配一个node</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">node_size</span><span class="p">(</span><span class="n">node_id</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span><span class="c1">//一个都不够分配了</span>
            <span class="k">if</span><span class="p">(</span><span class="n">size_left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">){</span>
                <span class="c1">//把剩余空间分配给相应free_list</span>
                <span class="cm">/*</span>
<span class="cm">                * 由于每次分配堆大小都是８的整数倍</span>
<span class="cm">                * 所以剩余的肯定属于8,16,24,...必然</span>
<span class="cm">                * 有一个与它完全适配,不会发生内存碎片</span>
<span class="cm">                */</span>
                <span class="kt">size_t</span> <span class="n">node_march</span> <span class="o">=</span> <span class="n">march_node</span><span class="p">(</span><span class="n">size_left</span><span class="p">);</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">size_left</span> <span class="o">==</span> <span class="n">node_size</span><span class="p">(</span><span class="n">node_march</span><span class="p">));</span>
                <span class="n">obj</span><span class="o">*</span> <span class="n">cur</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">*</span><span class="p">)</span><span class="n">start</span><span class="p">;</span>
                <span class="n">cur</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="n">node_march</span><span class="p">];</span>
                <span class="n">free_list</span><span class="p">[</span><span class="n">node_march</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">finish</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="kt">size_t</span> <span class="n">add_size</span> <span class="o">=</span> <span class="n">requre</span> <span class="o">+</span> <span class="p">(</span><span class="n">heap_size</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">);</span>
            <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="o">::</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="n">add_size</span><span class="p">));</span>
            <span class="k">if</span><span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
                <span class="c1">//分配内存失败</span>
                <span class="c1">//应该从合适的free_list中回收一定的内存</span>
                <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">node_id</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">FREE_COUNT</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
                    <span class="k">if</span><span class="p">(</span><span class="n">free_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">free_list</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                        <span class="n">free_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
                        <span class="n">start</span> <span class="o">=</span> <span class="n">result</span><span class="p">;</span>
                        <span class="n">finish</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">node_size</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
                        <span class="k">return</span> <span class="nf">chunk_alloc</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span><span class="c1">//再次尝试分配</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="c1">//实在不行调用一级空间适配器以调用用户定义的处理历程</span>
                <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">allocate</span><span class="p">(</span><span class="n">add_size</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="n">finish</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">add_size</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">requre</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">refill</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">node_id</span><span class="p">){</span>
     <span class="kt">size_t</span> <span class="n">chunk_num</span> <span class="o">=</span> <span class="n">CHUNK_NUM</span><span class="p">;</span>
     <span class="kt">void</span><span class="o">*</span> <span class="n">result</span><span class="p">;</span>
     <span class="n">result</span> <span class="o">=</span> <span class="n">chunk_alloc</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span> <span class="n">chunk_num</span><span class="p">);</span>
     <span class="c1">//chunk_num的值为实际分配到的块数目</span>
     <span class="n">obj</span><span class="o">*</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">*</span><span class="p">)</span><span class="n">result</span><span class="p">;</span>
     <span class="c1">//把chunk_num个内存块建立链表索引</span>
     <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">chunk_num</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
         <span class="n">obj</span><span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">*</span><span class="p">)((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">pos</span> <span class="o">+</span> <span class="n">node_size</span><span class="p">(</span><span class="n">node_id</span><span class="p">));</span>
         <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
         <span class="n">pos</span> <span class="o">=</span> <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
     <span class="p">}</span>
     <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">LARGE_SIZE</span><span class="p">){</span>
        <span class="c1">//超过LARGE_SIZE交给superior_allocator分配</span>
        <span class="k">return</span> <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">allocate</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="kt">size_t</span> <span class="n">node_id</span> <span class="o">=</span> <span class="n">march_node</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">if</span><span class="p">(</span><span class="n">free_list</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>
            <span class="c1">//已经没有资源了</span>
            <span class="n">free_list</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">*</span><span class="p">)</span><span class="n">refill</span><span class="p">(</span><span class="n">node_id</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
        <span class="n">free_list</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">reallocte</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">old_sz</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_sz</span><span class="p">){</span>
    <span class="kt">void</span><span class="o">*</span> <span class="n">new_ptr</span> <span class="o">=</span> <span class="n">allocate</span><span class="p">(</span><span class="n">new_sz</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">copy_sz</span> <span class="o">=</span> <span class="n">old_sz</span> <span class="o">&lt;</span> <span class="n">new_sz</span><span class="o">?</span> <span class="nl">old_sz</span> <span class="p">:</span> <span class="n">new_sz</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">new_ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">copy_sz</span><span class="p">);</span>
    <span class="n">deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">old_sz</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">new_ptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="kt">int</span> <span class="n">inst</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">junior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">deallocate</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">LARGE_SIZE</span><span class="p">)</span>
        <span class="n">superior_allocator</span><span class="o">&lt;</span><span class="n">inst</span><span class="o">&gt;::</span><span class="n">deallocate</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
    <span class="kt">size_t</span> <span class="n">node_march</span> <span class="o">=</span> <span class="n">march_node</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
    <span class="n">obj</span><span class="o">*</span> <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">pos</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">free_list</span><span class="p">[</span><span class="n">node_march</span><span class="p">];</span>
    <span class="n">free_list</span><span class="p">[</span><span class="n">node_march</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>


<h2>后记</h2>

<p>SGI的两级Allocator实现非常优美，特别是junior_allocator的实现，通过严密的管理策略使得几乎不会产生内存碎片.</p>

<p>另外，上面的代码只是笔者简单的模仿实现，SGI的源码则是更加的完整和健壮，并且对多线程情况也做出处理.</p>


    <!--    12015-->
    <div class="eof">-&nbsp;EOF&nbsp;-</div>
    <p class="declare">声明:本文采用<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/" target="_blank" rel="nofollow" title="署名-非商业性使用-相同方式共享">BY-NC-SA</a>协议进行授权.转载请注明: <a href="/c/c++/2015/04/15/%E4%BB%BF%E7%85%A7%E5%AE%9E%E7%8E%B0SGI-STL%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8.html" title="仿照实现SGI-STL空间配置器 " rel="nofollow">仿照实现SGI-STL空间配置器</a></p>
    <hr>
	<!-- bdshare provider -->	
	<style>
		.bdsharebuttonbox{
			float:right;
		}
	</style>
	<div class="bdsharebuttonbox">
		<a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
		<a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a>
		<a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a>
		<a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a>
		<a href="#" class="bds_more" data-cmd="more"></a>
	</div>
	<script>
		window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"1","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
	</script>
	<!--- end bdshare -->
	<!--- 
 -->
	
    <div class="pagination">
      <ul>
      
        <li class="prev"><a href="/algorithm/2015/04/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95.html" title="归并排序的迭代写法">&larr; Previous</a></li>
      
        <li><a href="/archive.html">Archive</a></li>
      
        <li class="next disabled"><a>Next &rarr;</a>
      
      </ul>
    </div>
    <hr>
    


      <div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'sosohu'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    





  </div>
  
  <div class="span4">

  
    <h4>Tags</h4>
    <ul class="tag_box">
    
    


  
     
    	<li><a href="/tags.html#STL-ref">STL <span>1</span></a></li>
    
  



    </ul>
    
  <h4>相关文章</h4>
  <ul>
  
  <li><a href="/algorithm/2015/04/14/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%86%99%E6%B3%95.html ">归并排序的迭代写法</a></li>
  
  <li><a href="/tool/2015/03/09/Xdotool%E6%A8%A1%E6%8B%9F%E5%B7%A5%E5%85%B7.html ">Xdotool工具</a></li>
  
  <li><a href="/experience/2015/02/06/Github-Jekyll-Markdown%E5%BC%80%E5%90%AF%E5%86%99%E4%BD%9C%E6%96%B0%E6%97%B6%E4%BB%A3.html ">Github-Jekyll-Markdown开启写作新时代</a></li>
  
  <li><a href="/tool/2015/02/05/Linux%E4%B8%8B%E5%B0%8F%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90.html ">Linux下小工具推荐</a></li>
  
  <li><a href="/c/c++/2014/12/10/C++%E7%9A%84this%E6%8C%87%E9%92%88.html ">C++的this指针</a></li>
  
  </ul>
  </div>
</div>
<script type="text/javascript" src="/assets/themes/flying/js/blogscript.js"></script>


      </div>

      <footer>
        <p>&copy; sosohu 2014 
          with help from <a href="http://jekyllbootstrap.com" target="_blank" title="The Definitive Jekyll Blogging Framework">Jekyll Bootstrap</a>
          and <a href="http://twitter.github.com/bootstrap/" target="_blank">Twitter Bootstrap</a>
	<!--script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1000067280'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s22.cnzz.com/z_stat.php%3Fid%3D1000067280%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script-->
	<script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_3815131'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s9.cnzz.com/stat.php%3Fid%3D3815131%26show%3Dpic' type='text/javascript'%3E%3C/script%3E"));</script>
        </p>
      </footer>

    </div> <!-- /container -->

    
    
  </body>

<script type="text/javascript">
$("a[href^='http://']").each(function(){
	this.target="_blank";

});
</script>

  <!--MathJax-->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
       }
  });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: {equationNumbers: {autoNumber: ["AMS"], useLabelIds: true},extensions: ["autobold.js"]},
        "HTML-CSS": {linebreaks: {automatic: true}},
        SVG: {linebreaks: {automatic: true}}
    });
</script>


<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<script type="text/javascript" src="/assets/themes/flying/js/default.js"></script>
 </html>


<!-- hitwebcounter Code START -->
<a href="http://www.hitwebcounter.com/" target="_blank">
<img src="http://hitwebcounter.com/counter/counter.php?page=6039789&style=0027&nbdigits=6&type=page&initCount=1122" title="" Alt=""   border="0" >
</a><br/>
<!-- hitwebcounter.com --><a href="http://www.hitwebcounter.com/" title="Hitwebcounter.com Free" 
target="_blank" style="font-family: Arial, Helvetica, sans-serif; 
font-size: 12px; color: #6B706A; text-decoration: underline ;"><strong>Hitwebcounter.com Free</strong>
</a>   
